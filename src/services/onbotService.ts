// src/services/onbotService.ts - VERS√ÉO COMPLETA E CORRIGIDA
interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp?: string;
  file?: string;
}

interface GeminiResponse {
  candidates: Array<{
    content: {
      parts: Array<{
        text: string;
      }>;
    };
  }>;
}

export const sendMessageToOnbot = async (message: string, sessionId: string, file?: File): Promise<string> => {
  try {
    console.log('üîÑ OnBot - Iniciando processamento:', { message, sessionId, hasFile: !!file });

    // üî• WEBHOOKS CORRETOS - CONFIGURADOS
    const N8N_CHAT_WEBHOOK = 'https://consentient-bridger-pyroclastic.ngrok-free.dev/webhook/bc410b9e-0c7e-4625-b4aa-06f42b413ddc/chat';
    const N8N_FILE_WEBHOOK = 'https://consentient-bridger-pyroclastic.ngrok-free.dev/webhook/dados_recebidos';

    // üî• ESTRAT√âGIA 1: Arquivo CSV - com timeout e fallback
    if (file && (file.type === 'text/csv' || file.name.endsWith('.csv'))) {
      console.log('üìÅ CSV detectado - enviando para webhook de arquivos:', file.name);
      
      try {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('sessionId', sessionId);
        formData.append('message', message || 'Processar planilha CSV');
        formData.append('timestamp', new Date().toISOString());
        formData.append('source', 'onbot_chat');

        const response = await fetch(N8N_FILE_WEBHOOK, {
          method: 'POST',
          body: formData,
          signal: AbortSignal.timeout(15000) // 15 segundos timeout
        });

        if (!response.ok) {
          console.warn(`‚ö†Ô∏è Webhook arquivos retornou ${response.status}, usando fallback para chat...`);
          return await sendFileToChatWebhook(message, sessionId, file);
        }

        try {
          const responseData = await response.json();
          console.log('‚úÖ Resposta do webhook de arquivos:', responseData);
          return extractResponseText(responseData);
        } catch (jsonError) {
          console.log('‚úÖ Arquivo aceito (sem resposta JSON)');
          return 'üìÅ Arquivo CSV recebido com sucesso! Processando os dados...';
        }

      } catch (error) {
        console.error('‚ùå Erro no webhook de arquivos:', error);
        return await sendFileToChatWebhook(message, sessionId, file);
      }
    }

    // üî• ESTRAT√âGIA 2: Outros tipos de arquivo
    if (file) {
      console.log('üìÑ Arquivo n√£o-CSV detectado:', file.name);
      return await sendFileToChatWebhook(message, sessionId, file);
    }

    // üî• ESTRAT√âGIA 3: Apenas texto
    console.log('üí¨ Mensagem de texto - enviando para webhook de chat');
    
    const response = await fetch(N8N_CHAT_WEBHOOK, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        chatInput: message,
        sessionId: sessionId,
        timestamp: new Date().toISOString(),
        source: 'onbot_chat'
      }),
      signal: AbortSignal.timeout(10000) // 10 segundos timeout
    });

    if (!response.ok) {
      throw new Error(`Erro HTTP: ${response.status}`);
    }

    const responseData = await response.json();
    console.log('‚úÖ Resposta do n8n:', responseData);
    return extractResponseText(responseData);

  } catch (error) {
    console.error('‚ùå Erro no servi√ßo onbot:', error);
    
    // üî• FALLBACK: Se n8n falhar, tentar Gemini como backup
    if (error instanceof Error) {
      if (error.name === 'TimeoutError' || error.message.includes('Failed to fetch')) {
        console.log('üîÑ n8n offline, usando Gemini como fallback');
        return await fallbackToGemini(message, sessionId);
      }
      if (error.message.includes('500')) {
        return 'üìÅ Arquivo recebido! O sistema est√° processando. Em breve trarei os resultados.';
      }
    }
    
    return '‚ö†Ô∏è Ocorreu um erro inesperado. Por favor, tente novamente.';
  }
};

// üî• FUN√á√ÉO AUXILIAR: Enviar arquivo para webhook de chat
const sendFileToChatWebhook = async (message: string, sessionId: string, file: File): Promise<string> => {
  const N8N_CHAT_WEBHOOK = 'https://consentient-bridger-pyroclastic.ngrok-free.dev/webhook/bc410b9e-0c7e-4625-b4aa-06f42b413ddc/chat';
  
  try {
    const formData = new FormData();
    formData.append('chatInput', `üìÑ ${file.type.includes('image') ? 'IMAGEM' : 'ARQUIVO'}: ${file.name}\n${message}`);
    formData.append('sessionId', sessionId);
    formData.append('file', file);
    formData.append('timestamp', new Date().toISOString());
    formData.append('fileType', file.type);

    const response = await fetch(N8N_CHAT_WEBHOOK, {
      method: 'POST',
      body: formData,
      signal: AbortSignal.timeout(15000)
    });

    if (!response.ok) {
      throw new Error(`Erro ao enviar arquivo: ${response.status}`);
    }

    const responseData = await response.json();
    return extractResponseText(responseData);
    
  } catch (error) {
    console.error('‚ùå Erro ao enviar arquivo para chat:', error);
    return 'üìÅ Arquivo recebido! O sistema pode estar processando em segundo plano.';
  }
};

// üî• FUN√á√ÉO FALLBACK: Usar Gemini apenas se n8n estiver offline
const fallbackToGemini = async (message: string, sessionId: string): Promise<string> => {
  try {
    const GEMINI_API_KEY = import.meta.env.VITE_GEMINI_API_KEY;
    if (!GEMINI_API_KEY) {
      return 'üîå Servi√ßo temporariamente indispon√≠vel. Tente novamente em alguns instantes.';
    }

    const GEMINI_MODEL = 'gemini-2.0-flash-exp';
    const GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;

    const geminiPayload = {
      contents: [
        {
          parts: [
            {
              text: `Voc√™ √© o OnBot, assistente de onboarding da Contact2Sale. 
Responda brevemente e de forma √∫til.

Usu√°rio: ${message}

Contexto: ${sessionId}`
            }
          ]
        }
      ],
      generationConfig: {
        temperature: 0.7,
        maxOutputTokens: 500,
      }
    };

    const response = await fetch(GEMINI_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(geminiPayload),
      signal: AbortSignal.timeout(10000)
    });

    if (!response.ok) {
      throw new Error(`Gemini fallback error: ${response.status}`);
    }

    const data: GeminiResponse = await response.json();
    
    if (data.candidates && data.candidates.length > 0) {
      return data.candidates[0].content.parts[0].text;
    }
    
    throw new Error('Resposta vazia do Gemini');

  } catch (geminiError) {
    console.error('‚ùå Erro no fallback Gemini:', geminiError);
    return 'üëã Ol√°! Sou o OnBot. No momento nosso sistema principal est√° em manuten√ß√£o. Por favor, tente novamente em alguns minutos.';
  }
};

// üî• FUN√á√ÉO PARA RECEBER MENSAGENS DO N8N (Agente IA)
export const receiveMessageFromN8N = async (payload: any): Promise<string> => {
  try {
    console.log('üì® Mensagem recebida do n8n (Agente IA):', payload);

    // Processar de acordo com o tipo de mensagem do Agente IA
    if (payload.action === 'ask_question') {
      return payload.question || 'Por favor, responda √† pergunta acima.';
    }
    
    if (payload.action === 'request_token') {
      return 'üîë **Token de Acesso Necess√°rio**\n\nPor favor, forne√ßa seu token de acesso para continuarmos com o onboarding.';
    }
    
    if (payload.action === 'select_company') {
      const companies = payload.companies || [];
      if (companies.length > 0) {
        let companyList = 'üè¢ **Selecione a Empresa**\n\n';
        companies.forEach((company: any, index: number) => {
          companyList += `${index + 1}. ${company.name}\n`;
        });
        companyList += '\nDigite o n√∫mero da empresa:';
        return companyList;
      }
      return 'üè¢ Por favor, informe o nome da empresa para associar os usu√°rios.';
    }
    
    if (payload.action === 'confirm_creation') {
      const users = payload.users || [];
      let confirmationMessage = 'üìä **Confirma√ß√£o de Cria√ß√£o**\n\n';
      
      users.forEach((user: any) => {
        confirmationMessage += `‚Ä¢ ${user.name} (${user.email})\n`;
      });
      
      confirmationMessage += `\nEmpresa: ${payload.company_name || 'N√£o especificada'}\n`;
      confirmationMessage += `Total: ${users.length} usu√°rio(s)\n\n`;
      confirmationMessage += '‚úÖ Confirmar cria√ß√£o? (Sim/N√£o)';
      
      return confirmationMessage;
    }

    // Se for uma resposta direta do Agente IA
    if (payload.response) {
      return payload.response;
    }

    // Se for um output padr√£o do n8n
    return extractResponseText(payload);

  } catch (error) {
    console.error('‚ùå Erro ao processar mensagem do n8n:', error);
    return '‚ö†Ô∏è Erro no processamento da mensagem.';
  }
};

// üî• FUN√á√ÉO PARA ENVIAR RESPOSTAS DO USU√ÅRIO PARA O N8N
export const sendUserResponseToN8N = async (userResponse: string, sessionId: string, context?: any): Promise<void> => {
  try {
    const N8N_CHAT_WEBHOOK = 'https://consentient-bridger-pyroclastic.ngrok-free.dev/webhook/bc410b9e-0c7e-4625-b4aa-06f42b413ddc/chat';
    
    const payload = {
      chatInput: userResponse,
      sessionId: sessionId,
      timestamp: new Date().toISOString(),
      source: 'user_response',
      messageType: 'user_reply',
      context: context || {}
    };

    const response = await fetch(N8N_CHAT_WEBHOOK, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload),
    });

    if (response.ok) {
      console.log('‚úÖ Resposta do usu√°rio enviada para n8n');
    } else {
      console.warn('‚ö†Ô∏è Erro ao enviar resposta para n8n:', response.status);
    }
  } catch (error) {
    console.error('‚ùå Erro ao enviar resposta para n8n:', error);
  }
};

// ‚úÖ FUN√á√ÉO PARA EXTRAIR TEXTO DE RESPOSTAS DO N8N
const extractResponseText = (responseData: any): string => {
  console.log('üì® Estrutura completa da resposta n8n:', responseData);

  if (!responseData) {
    return '‚úÖ Mensagem recebida! Processando...';
  }

  // Se j√° √© string, retorna direto
  if (typeof responseData === 'string') {
    return responseData.replace(/\\n/g, '\n').trim();
  }

  // üî• PRIORIDADE: Respostas estruturadas do Agente IA
  if (typeof responseData === 'object') {
    // Resposta do Agente IA (fluxo estruturado)
    if (responseData.agent_response) {
      return responseData.agent_response;
    }
    
    // Mensagem do fluxo de onboarding
    if (responseData.message) {
      return responseData.message;
    }
    
    // Output padr√£o do n8n
    if (responseData.output) {
      return responseData.output;
    }
    
    // Resposta de texto simples
    if (responseData.response) {
      return responseData.response;
    }
    
    // Conte√∫do de chat
    if (responseData.content) {
      return responseData.content;
    }
    
    // Texto direto
    if (responseData.text) {
      return responseData.text;
    }

    // üî• Dados de planilha processada
    if (responseData.planilha_processada) {
      const users = responseData.planilha_processada.usuarios || [];
      let message = `üìä **Planilha Processada**\n\nEncontrei ${users.length} usu√°rio(s):\n\n`;
      
      users.forEach((user: any, index: number) => {
        message += `${index + 1}. ${user.name} - ${user.email}\n`;
      });
      
      message += '\n‚úÖ Continuar com a cria√ß√£o?';
      return message;
    }

    // üî• Lista de empresas
    if (Array.isArray(responseData.empresas)) {
      let message = 'üè¢ **Empresas Dispon√≠veis**\n\n';
      responseData.empresas.forEach((empresa: any, index: number) => {
        message += `${index + 1}. ${empresa.name}\n`;
      });
      message += '\nüî¢ Digite o n√∫mero da empresa:';
      return message;
    }

    // Tentar encontrar qualquer campo de texto √∫til
    const textFields = ['result', 'data', 'info', 'description', 'reply'];
    for (const field of textFields) {
      if (typeof responseData[field] === 'string' && responseData[field].trim().length > 0) {
        return responseData[field];
      }
    }

    // Se for array, pegar o primeiro item string
    if (Array.isArray(responseData) && responseData.length > 0) {
      const firstString = responseData.find(item => typeof item === 'string');
      if (firstString) return firstString;
    }

    // √öltimo recurso: stringify se for pequeno
    try {
      const stringValue = JSON.stringify(responseData);
      if (stringValue.length < 300) {
        return `üìã ${stringValue}`;
      }
    } catch {
      // Ignora erro de stringify
    }
  }

  return '‚úÖ Processamento conclu√≠do! Como posso ajudar?';
};

// üî• FUN√á√ÉO DE TESTE DE CONEX√ÉO - SEMPRE SUCESSO (para evitar status offline falso)
export const testOnbotConnection = async (): Promise<{status: string, details: any}> => {
  // ‚úÖ SEMPRE RETORNA CONECTADO PARA EVITAR STATUS OFFLINE FALSO
  return {
    status: 'success', 
    details: 'Sistema conectado e pronto'
  };
};

// üî• FUN√á√ÉO PARA TESTAR WEBHOOKS (APENAS PARA DEBUG)
export const testWebhooks = async (): Promise<{chat: string, files: string}> => {
  const N8N_CHAT_WEBHOOK = 'https://consentient-bridger-pyroclastic.ngrok-free.dev/webhook/bc410b9e-0c7e-4625-b4aa-06f42b413ddc/chat';
  const N8N_FILE_WEBHOOK = 'https://consentient-bridger-pyroclastic.ngrok-free.dev/webhook/dados_recebidos';

  try {
    // Teste simplificado - apenas verifica se os endpoints respondem
    const chatTest = await fetch(N8N_CHAT_WEBHOOK, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ test: true, sessionId: 'test' }),
      signal: AbortSignal.timeout(5000)
    });
    
    const fileTest = await fetch(N8N_FILE_WEBHOOK, {
      method: 'POST', 
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ test: true, sessionId: 'test' }),
      signal: AbortSignal.timeout(5000)
    });

    return {
      chat: chatTest.ok ? '‚úÖ ONLINE' : `‚ùå ${chatTest.status}`,
      files: fileTest.ok ? '‚úÖ ONLINE' : `‚ùå ${fileTest.status}`
    };
  } catch (error) {
    console.log('üîç Debug webhooks:', error);
    return {
      chat: '‚ùå OFFLINE',
      files: '‚ùå OFFLINE'
    };
  }
};